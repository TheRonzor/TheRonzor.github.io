<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="style.css">
    <!-- Link to import the d3 javascript library -->
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <!-- Link to import the MathJax typesetting library -->
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
    <!-- My libraries -->
    <script src='ronzor_lib1.js'></script>
    <script src='rz_fourier.js'></script>
</head>
  <body class="bd-main">
    <div class="nav-bar-wrapper">
      <ul class="nav-bar">
        <li><a href="index.html">Home</a></li>
        <li><a href="About.html">About</a></li>
        <li><a class="active" href="visual_fourier.html">Math is Fun!</a></li>
        <li><a href="photo.html">Photography</a></li>
        <li><a href="resume.html">CV</a></li>
      </ul>
	</div>
      
    <div class="pad-top" id="intro">
      <h1 class="h1-main"> The Visual Fourier Transform </h1>
      <p class="p-math-big">$$ F(\omega) = \int f(t) e^{i\omega t} dt $$</p>
    </div>
      
    <div id="sine-example" class="d3-center">
        <p> The Fourier transform is a technique that can be used to extract the
        frequency content of a signal. But why does it work?  Let's see if we can follow a simple line of reasoning and invent this method ourselves!</p>
        <h2 class="h2-main" style="text-align: left"> The Question </h2>
        <p  style="text-align: left"> The question we're basically asking is, "how long until the signal looks the same again?". Let's think about what that means.  Here's a simple signal, just a pure cosine wave, \( f(t) = \cos(t) \): </p>
        <script>
            (function(){
                const margin={top:60,left:60,bottom:60,right:60},
                      height = 300,
                      width = 600,
                      xMin = 0, xMax = 20, 
                      yMin = -2, yMax = 2,
                      tMin = 0, tMax = 20, tSteps = 1000-1; // Unused but the next function doesn't have optional inputs yet

                out = make_standard_axes("#sine-example", height, width, margin, xMin, xMax, yMin, yMax, tMin, tMax, "white");
                svg_sine = out[0]; X = out[1]; Y = out[2]; T = out[3];

                // Label the axes - need to figure out how to get math font in there
                svg_sine.append("text")
                    .attr("x", (width - margin.right - margin.left)/2)
                    .attr("y", height*0.75)
                    .style("text-anchor", "middle")
                    .text("t");
                svg_sine.append("text")
                    .attr("x", -0.09*width)
                    .attr("y", (height-margin.top-margin.bottom)/2)
                    .style("text-anchor", "middle")
                    .text("f(t)");
                var xt = X.ticks(tSteps),
                    yt = X.ticks(tSteps).map(function(x) { return Math.cos(x)} ),
                    path_d = make_svg_path_from_data(xt,yt,X,Y);
                svg_sine.append('path')
                    .attr('d', path_d)
                    .style('fill','none')
                    .style('stroke', 'blue')
                    .style('stroke-width', '2px');
            }()) //end of IIFE
        </script>
        
        <p> <em>Technical note: The aficionado may have noticed the missing factors of \( 2\pi \). I've rescaled time for simplicity!</em></p>
        
        <p style="text-align:left"> As we often do in real life, let's think about time as a clock.  After some time (namely, 24 hours) the clock looks the same again.  Let's connect these two ideas and ask, "how fast does the clock need to tick so that the signal looks the same whenever the clock looks the same?".  Below is a representation of this hypothetical clock.  We'll control how fast it ticks by multiplying the actual time, \( t \), by some factor we'll call \( \omega \).  Think about \( \omega \) as being controlled by some knob we can turn up or down:</p>
      </div>

    <div id ="clock-example" class="d3-center">
        <script>
            (function(){
                const margin={top:60,left:60,bottom:60,right:60},
                      height = 600,
                      width = 600,
                      xMin = -1, xMax = 1, 
                      yMin = -1, yMax = 1,
                      tMin = 0, tMax = 20, tSteps = 1000-1;
                out = make_standard_axes("#clock-example", height, width, margin, xMin, xMax, yMin, yMax, tMin, tMax, "white");
                svg_clock = out[0]; X_c = out[1]; Y_c = out[2]; T_c = out[3];

                svg_clock.append("text")
                    .attr("x", (width - margin.right - margin.left)/2)
                    .attr("y", height*0.87)
                    .style("text-anchor", "middle")
                    .text("x(t)");
                svg_clock.append("text")
                    .attr("x", -0.08*width)
                    .attr("y", (height-margin.top-margin.bottom)/2)
                    .style("text-anchor", "middle")
                    .text("y(t)");

                var xt_c = T.ticks(tSteps).map(function(t) { return Math.cos(t)} )
                    yt_c = T.ticks(tSteps).map(function(t) { return Math.sin(t)} ),
                    path_d = make_svg_path_from_data(xt_c, yt_c, X_c, Y_c);
                svg_clock.append('path')
                    .attr('d', path_d)
                    .style('fill','none')
                    .style('stroke', 'gray')
                    .style('stroke-width', '2px');

                //----------------------
                var dt = 0.01,
                    curT = 0,
                    curW = 1,
                    dW = 0.005;
                    adjust_w_mode = 0;
                const tau = 2*Math.PI;
                d3.interval(function() {
                    curT = (curT + dt);
                    switch (adjust_w_mode) {
                        case 1:
                            curW = curW + dW;
                            if (curW >= 2) {
                                curW = 2;
                                adjust_w_mode=0;
                            };
                            break;
                        case -1:
                            curW = curW - dW;
                            if (curW <= 1) {
                                curW = 1;
                                adjust_w_mode=0;
                            };
                            break;
                        default:
                            break;
                    }
                    draw_clock_arm(curW, curT);
                    if (curT > tau) {
                        curT = curT % tau;
                        switch (curW) {
                            case 1:
                                adjust_w_mode = 1;
                                break;
                            case 2:
                                adjust_w_mode = -1;
                                break;
                            default:
                                break;
                        }
                    }
                    }, 0
                );
                //----------------------

                function draw_clock_arm(w, t) {
                    var x, y;  
                    x = Math.cos(t * w);
                    y = Math.sin(t * w);
                    d3.select("#curTimeLine").remove()
                    svg_clock.append("line")
                        .attr("x1", X_c(0))
                        .attr("y1", Y_c(0))
                        .attr("x2", X_c(x))
                        .attr("y2", Y_c(y))
                        .style("stroke", "red")
                        .style('stroke-width', '2px')
                        .attr("id", "curTimeLine");

                    d3.select("#curTime").remove()
                    svg_clock.append("circle")
                        .attr("cx", X_c(x))
                        .attr("cy", Y_c(y))
                        .attr("r", 5)
                        .attr("fill","red")
                        .attr("id", "curTime");

                    d3.select("#clockTitle").remove()
                    svg_clock.append("text")
                        .attr("id", "clockTitle")
                        .attr("x", (width - margin.top - margin.bottom)/2)
                        .attr("y", -8)
                        .style("text-anchor", "middle")
                        .style("font-size", "16px")
                        .text("\u03c9 = " + (Math.round(w*100)/100).toFixed(2));
                }

            }()) // end of IIFE
        </script>
        <p style="text-align: left"> The reader with some math knowledge might recognize this "clock" as \( e^{i\omega t} \); the equation describing a particle moving around a unit circle with speed proportional to \( \omega\).  An equivalent representatation is \( e^{i \omega t} = \cos(\omega t) + i \sin(\omega t) \) - which should seem somewhat magical if you haven't seen it before!</p>
        <p style="text-align: left"> You might see where this is going.  Let's find a way attach our signal to the moving clock arm. At every point in time, our signal has some real-valued amplitude, and the arm of the clock is 1 unit away from the origin at some angle which is determined by \( \omega \), which we will now call the winding frequency.</p>
      </div>

      <div id="clock-with-sine" class = "d3-center">
        <script>
            (function(){
                const margin={top:60,left:60,bottom:60,right:60},
                      height = 600,
                      width = 600,
                      xMin = -1, xMax = 1, 
                      yMin = -1, yMax = 1,
                      tMin = 0, tMax = 20, tSteps = 1000-1;
                out = make_standard_axes("#clock-with-sine", height, width, margin, xMin, xMax, yMin, yMax, tMin, tMax, "white");
                svg_cws = out[0]; X_cws = out[1]; Y_cws = out[2]; T_cws = out[3];

                svg_cws.append("text")
                    .attr("x", (width - margin.right - margin.left)/2)
                    .attr("y", height*0.87)
                    .style("text-anchor", "middle")
                    .text("x(t)");
                svg_cws.append("text")
                    .attr("x", -0.08*width)
                    .attr("y", (height-margin.top-margin.bottom)/2)
                    .style("text-anchor", "middle")
                    .text("y(t)");

                var xt_cws = T.ticks(tSteps).map(function(t) { return Math.cos(t)} )
                    yt_cws = T.ticks(tSteps).map(function(t) { return Math.sin(t)} ),
                    path_d = make_svg_path_from_data(xt_cws, yt_cws, X_cws, Y_cws);
                svg_cws.append('path')
                    .attr('d', path_d)
                    .style('fill','none')
                    .style('stroke', 'gray')
                    .style('stroke-width', '2px');

                //----------------------
                var dts = 0.01,
                    curTs = 0,
                    curWs = 1,
                    dWs = 0.005;
                    adjust_w_modes = 0;
                const tau = 2*Math.PI;
                draw_wound_signal(curWs, curTs)
                d3.interval(function() {
                    curTs = (curTs + dts);
                    switch (adjust_w_modes) {
                        case 1:
                            curWs = curWs + dWs;
                            if (curWs > 2) {
                                curWs = 2;
                                adjust_w_modes=0;
                            };
                            break;
                        case -1:
                            curWs = curWs - dWs;
                            if (curWs < 1) {
                                curWs = 1;
                                adjust_w_modes=0;
                            };
                            break;
                        default:
                            break;
                    }
                    draw_wound_signal(curWs, curTs);
                    draw_clock_arm_times_signal(curWs, curTs);
                    
                    if (curTs > tau) {
                        curTs = curTs % tau;
                        switch (curWs) {
                            case 1:
                                adjust_w_modes = 1;
                                break;
                            case 2:
                                adjust_w_modes = -1;
                                break;
                            default:
                                break;
                        }
                    }
                    }, 0
                );
                //----------------------
                
                function fourier(k) {
                    var fx = function(t) { return ( Math.cos(t)*Math.cos(k*t) )};
                    var fy = function(t) { return ( Math.cos(t)*Math.sin(k*t) )};
                    return [fx,fy];
                }
                function draw_wound_signal(w, t) {
                    var f = fourier(w);
                    xt_sig = T.ticks(tSteps).map(function(t) { return f[0](t)} );
                    yt_sig = T.ticks(tSteps).map(function(t) { return f[1](t)} );
                    path_sig = make_svg_path_from_data(xt_sig, yt_sig, X_cws, Y_cws);
                    
                    d3.select("#lastWoundSignal").remove();
                    svg_cws.append("path")
                        .attr("d", path_sig)
                        .style('fill','none')
                        .style('stroke', 'blue')
                        .style('stroke-width', '2px')
                        .attr("id", "lastWoundSignal");
                }

                function draw_clock_arm_times_signal(w, t) {
                    var x, y;  
                    x = Math.cos(t * w) * Math.cos(t);
                    y = Math.sin(t * w) * Math.cos(t);
                    d3.select("#curTimeLine2").remove()
                    svg_cws.append("line")
                        .attr("x1", X_cws(0))
                        .attr("y1", Y_cws(0))
                        .attr("x2", X_cws(x))
                        .attr("y2", Y_cws(y))
                        .style("stroke", "red")
                        .style('stroke-width', '2px')
                        .attr("id", "curTimeLine2");

                    d3.select("#curTime2").remove()
                    svg_cws.append("circle")
                        .attr("cx", X_cws(x))
                        .attr("cy", Y_cws(y))
                        .attr("r", 5)
                        .attr("fill","red")
                        .attr("id", "curTime2");

                    d3.select("#clockTitle2").remove()
                    svg_cws.append("text")
                        .attr("id", "clockTitle2")
                        .attr("x", (width - margin.top - margin.bottom)/2)
                        .attr("y", -8)
                        .style("text-anchor", "middle")
                        .style("font-size", "16px")
                        .text("\u03c9 = " + (Math.round(w*100)/100).toFixed(2));
                }

            }()) // end of IIFE
        </script>
      </div>
      
      <div id="old-text">
        <p>After thinking about that for a minute, you might
        realize that if we were to wrap the signal around a circle at one of its
        dominant frequencies, the picture would look like some curve laying on
        top of itself, since every time it reaches the same angle (phase) it
        will have the same value (amplitude, or distance from the origin). </p>
        <p> On the other hand, if we wrap the signal around a circle at some other
        frequency, then we'll get some sort of spirograh looking mess that, on
        average, will be centered around the origin. </p>
        <p> The visualization below is the function obtained before doing any
        integration. That is, it is the function we obtain when we multiply our
        signal by a unit circle at varying winding frequencies. </p>
        <p> The signal used in this example is </p>
        <p class="p-math">$$f(t) = \cdots $$</p>
        <p> When the winding frequency matches one of the actual frequencies (1,3,
        and 7) we expect to see the signal laying on top of itself, and the
        distance to the center of mass from the origin will be proportional to
        the amplitude of the signal at that frequency. At other freqeuncies, the
        signal will not line up with itself, so the center of mass will be
        closer to the origin. </p>
        <p> Now you know! We're currently working on building interactive
        animations, so check back later for more fun stuff! </p>
    </div>
      <div id="d3-part3" class="d3-center">
        <script>
            (function(){
                // Define dimensions and margins
                const margin={top:50,left:50,bottom:50,right:50},
                      height = 600,
                      width = 600,
                      xMin = -2, xMax = 2, 
                      yMin = -2, yMax = 2,
                      tMin = 0, tMax = 20, tSteps = 1000-1;
                // This function will return the svg object as well as X,Y, and T as linearScale objects, 
                // and also draw the axes and background
                out = make_standard_axes("#d3-part3", height, width, margin, xMin, xMax, yMin, yMax, tMin, tMax, "white");
                svg = out[0]; X = out[1]; Y = out[2]; T = out[3];

                // Mark zero - and make sure it's actually zero!
                svg.append("circle")
                        .attr("cx", X(0))
                        .attr("cy", Y(0))
                        .attr("r",10)
                        .attr("fill","pink")
                        .attr("id","test_zero");

                // --------------- Now we do the actual plotting ----------------
                // --------------------------------------------------------------
                var xt, yt,
                    winding = 0,
                    wStep  = 0.005,
                    wMax = 10;
                    waitTime = 30;
                // d3.interval will execute every [waitTime] milliseconds.
                d3.interval(function() {
                    winding = winding + wStep;
                    winding = winding % wMax;
                    make_plot(winding);
                    
                    // Add the center of mass + a line from the origin
                    com = get_center_of_mass(xt, yt);
                    d3.select("#com-line").remove();
                    svg.append("line")
                        .style("stroke", "red")
                        .style('stroke-width', '2px')
                        .attr("x1", X(0))
                        .attr("y1", Y(0))
                        .attr("x2", X(com[0]))
                        .attr("y2", Y(com[1]))
                        .attr("id", "com-line");
                    d3.select("#com").remove();
                    svg.append("circle")
                        .attr("cx", X(com[0]))
                        .attr("cy", Y(com[1]))
                        .attr("r",5)
                        .attr("fill","red")
                        .attr("id","com");
                    }, waitTime
                );
                // --------------------------------------------------------------
                // --------------------------------------------------------------

                
                // The function to compute the function and update the plot
                function make_plot(k) {
                    // This could be replaced with any function
                    var f = fourier(k);

                    // Evaluate the function
                    xt = T.ticks(tSteps).map(function(ti) { return f[0](ti)} );
                    yt = T.ticks(tSteps).map(function(ti) { return f[1](ti)} );

                    // Build SVG path string
                    var path_d = make_svg_path_from_data(xt, yt, X, Y);

                    // Remove the old stuff
                    d3.select("#lastCurve").remove();
                    d3.select("#theTitle").remove();

                    // Add the new stuff
                    svg.append('path')
                        .attr('d', path_d)
                        .attr("id", "lastCurve")
                        .style('fill','none')
                        .style('stroke', 'blue')
                        .style('stroke-width', '2px');
                    svg.append("text")
                        .attr("id", "theTitle")
                        .attr("x", (width - margin.top - margin.bottom)/2)
                        .attr("y", -5)
                        .style("text-anchor", "middle")
                        .style("font-size", "16px")
                        .text("\u03c9 = " + (Math.round(winding*100)/100).toFixed(2));
                    }
                // Return two functions of time based on an input parameter
                var s = Math.sin,
                    c = Math.cos;
                function fourier(k) {
                    var fx = function(t) { return ( MySignal(t)*c(k*t) )};
                    var fy = function(t) { return ( MySignal(t)*s(k*t) )};
                    return [fx,fy];
                }
                // The signal to be transformed
                function MySignal(t) {
                    return (0.5*s(2*t) + 1.3*s(5*t + 0.7));
                }
                 
        }())
        </script>
    </div>
  </body>
</html>
